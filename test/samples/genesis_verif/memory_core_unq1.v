//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /Users/dillon/VerilogWorkspace/CGRAGenerator/hardware/generator_z/memory_core/memory_core.vp
//  Source template: memory_core
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter ddepth 	= 1024
// Parameter dwidth 	= 16
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

///////////////////////////////////////////////////////////////////
// CGRA memory generator
//////////////////////////////////////////////////////////////////


`define xassert(condition, message) //if(condition) begin $display(message); $finish(1); end


// dwidth (_GENESIS2_INHERITANCE_PRIORITY_) = 16
//
// ddepth (_GENESIS2_INHERITANCE_PRIORITY_) = 0x400
//

module memory_core_unq1(
clk,
config_addr,
config_data,
config_en,
xdata_in,
data_out,
chain_in,
chain_out,
addr,
addr_w,
xwen,
chain_wen_in,
ren,
valid,
chain_valid_out,
almost_full,
reset
);

input clk;
input [31:0] config_addr;
input [31:0] config_data;
input config_en;
input [15:0] xdata_in;
input [15:0] addr;
input [15:0] addr_w;
output reg [15:0] data_out;
input [15:0] chain_in;
output [15:0] chain_out;
input xwen;
input chain_wen_in;
output chain_valid_out;
input ren;
output reg valid;
output reg almost_full;
input reset;

reg int_valid;
reg int_valid_d1;
wire gclk;
wire [15:0] data_in;
reg phase;
reg [31:0] config_mem;
reg [15:0] mem_data_in0;
reg [15:0] mem_data_in1;
wire [15:0] mem_data_out0;
wire [15:0] mem_data_out1;
reg [15:0] fifo_wr_addr;
reg [15:0] fifo_rd_addr;
reg [15:0] fifo_count;
reg [15:0] lb_ren_count;

wire wen;
wire int_ren;
reg  int_ren_sync_to_read_phase;
reg  [15:0] int_ren_sync_to_read_phase_count;
reg  int_ren_d1;
wire int_wen;
wire int_cen;
reg  lb_ren;
reg [1:0] lb_ren_state;
reg [1:0] out_count;
wire [12:0] fifo_depth;
wire [12:0] fifo_depthm1;
wire [12:0] fifo_depthm4;
reg WENHACK;


reg [15:0] mem_addr;
reg [15:0] addr_d1;
reg [47:0] in_sr;
reg [1:0] input_count;
reg [31:0] out_sr;
reg [15:0] data_out_d1;
reg out_delay;
reg mv_to_ram;
reg mv_to_out;

assign gclk = clk & (config_mem[2]==1'b1);
assign data_in = (config_mem[19]==1'b1)?chain_in:xdata_in;

assign fifo_depth = config_mem[15:3];
assign fifo_depthm1 = fifo_depth - 16'd1;
assign fifo_depthm4 = fifo_depth - 16'd4;
// At the last minute, run.csh can modify line below
// to read "asssign  wen = WENHACK" instead
assign wen = (config_mem[19]==1'b1)?chain_wen_in:xwen;

assign chain_out = data_out;
assign chain_valid_out = valid;

always @(posedge clk) begin
  if (reset==1'b1) begin
    config_mem <= 32'd0;
  end else begin
    if (config_en==1'b1) begin
       case (config_addr[31:24])
         8'd0: config_mem[31:0] <= config_data;
       endcase
    end
  end
end

always @(posedge clk) begin
  if (reset==1'b1) begin
    phase <= 1'b0;
  end else begin
    phase <= ~phase;
  end
end

assign int_wen = (config_mem[1:0]==2'd1||config_mem[1:0]==2'd0)?mv_to_ram:wen;
assign int_ren = (config_mem[1:0]==2'd0)?lb_ren:ren;
assign int_cen = int_wen | int_ren;

wire [15:0] fifo_d;
assign fifo_d = (fifo_depth>>1);

always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    fifo_wr_addr <= 0;
    fifo_rd_addr <= 0;
    fifo_count <= 0;
  end else begin
    if (config_mem[1:0]==2'd1||config_mem[1:0]==2'd0) begin
      if (int_wen==1'b1 && phase==1'b1) begin
        if (fifo_count < fifo_d) begin
          fifo_count <= fifo_count + 1;
          if (fifo_wr_addr < (fifo_d  - 16'd1)) begin
            fifo_wr_addr <= fifo_wr_addr + 1;
          end else begin
            fifo_wr_addr <= 0;
          end
        end
      end else if (int_ren==1'b1 && phase==1'b0) begin
        if (fifo_count>0) begin 
          fifo_count <= fifo_count - 1;
          if (fifo_rd_addr < (fifo_d  - 16'd1)) begin
            fifo_rd_addr <= fifo_rd_addr + 1;
          end else begin
            fifo_rd_addr <= 0;
          end
        end
      end
    end 
  end
end

always @(*) begin
  if (config_mem[1:0]==2'd2) begin
    mem_addr <= addr;
  end else begin
    mem_addr <= (phase==1'b0)?fifo_rd_addr:fifo_wr_addr;
  end
end

`define MV_TO_RAM (phase==1'b0 && (input_count > 2'd1 || (input_count==2'd1 && wen)))
`define MV_TO_OUT (int_ren && fifo_count==0 && input_count > 2'd0)
`define MV (`MV_TO_RAM || `MV_TO_OUT)

always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    input_count <= 2'd0;
  end else begin
    if (wen==1'b1 && ~(mv_to_ram|mv_to_out)) begin
      //$display ("case 1 (does this work?)");
      in_sr <= {in_sr[31:0],data_in};
      `xassert(input_count==2'd3, "error: input_count increasing beyond 3")
      input_count <= input_count + 2'd1;
    end else if (wen==1'b1 && (mv_to_ram|mv_to_out)) begin
      //$display ("case 2 (does this work?)");
      in_sr[31:0] <= {in_sr[15:0],data_in};
      `xassert(input_count==2'd0, "error: input_count decreasing beyond 0. case 1.")
      input_count <= input_count - 2'd1;
    end else if (wen==1'b0 && (mv_to_ram)) begin
      //$display ("case 3 (does this work?)");
      `xassert(input_count<2'd2, "error: input_count decreasing beyond 0. case 2.")    
      input_count <= input_count - 2'd2;
    end else if (wen==1'b0 && (mv_to_out)) begin
      //$display ("case 4 (does this work?)");
      input_count <= 0;
    //end else begin
      //$display("Wait, what?");
      //$display("The value of wen is: %b", wen) ;
      //$display("The value of mv_to_ram is: %b", mv_to_ram) ;
      //$display("The value of mv_to_out is: %b", mv_to_out) ;
      //$display("mv_to_ram|mv_to_out is: %b", mv_to_ram|mv_to_out) ;
      //$display("~(mv_to_ram|mv_to_out) is: %b", ~(mv_to_ram|mv_to_out)) ;
    end
  end
end

always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    mv_to_ram <= 1'b0;
  end else begin
    if `MV_TO_RAM begin
      mv_to_ram <= 1'b1;
    end else begin
      mv_to_ram <= 1'b0;
    end
  end
end

always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    mv_to_out <= 1'b0;
  end else begin
    if `MV_TO_OUT begin
      mv_to_out <= 1'b1;
    end else begin
      mv_to_out <= 1'b0;
    end
  end
end

always @(posedge clk) begin
  if (((fifo_count<<1)+input_count) >= (fifo_depth - config_mem[18:16])) begin
    almost_full <= 1'b1;
  end else begin
    almost_full <= 1'b0;
  end
end

`define MV_RAM_TO_OUTPUT (int_ren_sync_to_read_phase && phase && ~mv_to_out)
`define MV_INPUT_TO_OUTPUT (int_ren_sync_to_read_phase && phase && mv_to_out)

wire mv_ram_to_output = `MV_RAM_TO_OUTPUT;
wire mv_input_to_output = `MV_INPUT_TO_OUTPUT;

always @(posedge clk) begin
  int_valid <= int_ren_sync_to_read_phase || (~int_ren_sync_to_read_phase && int_ren==1'b1 && phase==1'b0 && (out_count >0));
  int_valid_d1 <= int_valid;
  //((out_count>0) || `MV_RAM_TO_OUTPUT || `MV_INPUT_TO_OUTPUT);
end

always @(*) begin
  valid <= (out_delay==1'b1)?int_valid_d1:int_valid;
end

always @(posedge clk or posedge reset) begin
   if (reset==1'b1) begin
     WENHACK = 1'b0;
   end else if (data_in != 16'b0) begin
     WENHACK = 1'b1;
   end
end

always @(posedge clk or posedge reset) begin
   if (reset==1'b1) begin
     lb_ren_state <= 2'd0;
     lb_ren_count <= 2'd0;
   end else begin
     if ((((fifo_count<<1)+input_count)>=(fifo_depthm4)) && lb_ren_state==2'd0 ) begin
       lb_ren_state <= 2'd1;
       lb_ren_count <= out_count;
     //NB: Disabling LB items count check when restarting row output. Since we hide latency by early reading of fifo,
     //  : sufficient data does not get accumulated for the next line to start (for the continuous streaming case).
     end else if ((lb_ren_count>=(fifo_depthm1)) && lb_ren_state==2'd1 && ((((fifo_count<<1)+input_count)>=fifo_depth)|1'b1)) begin
       lb_ren_count <= out_count;     
     end else if ((lb_ren_count>=(fifo_depthm1)) && lb_ren_state==2'd1 && ((((fifo_count<<1)+input_count)<fifo_depth)|1'b1)) begin
       lb_ren_state <= 2'd0;
     end else if (lb_ren_state==2'd1) begin
       lb_ren_count <= lb_ren_count + 16'd1;
     end
   end
end

always @(*) begin
  lb_ren <= (lb_ren_state==2'd1);
end

always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    int_ren_sync_to_read_phase <= 1'b0;
    int_ren_sync_to_read_phase_count <= 16'd0;
  end else if ((int_ren_sync_to_read_phase == 1'b1) && (int_ren_sync_to_read_phase_count >= fifo_depthm1)) begin
    int_ren_sync_to_read_phase <= int_ren;
    int_ren_sync_to_read_phase_count <= out_count; 
  end else if ((int_ren_sync_to_read_phase == 1'b0) && phase == 1'b0) begin 
    int_ren_sync_to_read_phase <= int_ren;
    int_ren_sync_to_read_phase_count <= out_count;    
  end else if (int_ren_sync_to_read_phase == 1'b1) begin
    int_ren_sync_to_read_phase_count <= int_ren_sync_to_read_phase_count + 16'd1;        
  end
end

always @(posedge clk) begin
  int_ren_d1 <= int_ren;
end

always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    out_delay <= 1'b0;
  end else begin
    if (int_ren_d1==1'b0 && int_ren==1'b1 && phase == 1'b0) begin
      out_delay <= 1'b1;
    end else if (int_ren_d1==1'b0 && int_ren==1'b1 && phase == 1'b1) begin
      out_delay <= 1'b0;
    end
  end
end

always @(*) begin
  if (config_mem[1:0]==2'd1||config_mem[1:0]==2'd0) begin
    if (input_count==2'd3) begin
      {mem_data_in1,mem_data_in0} <= {in_sr[47:16]};
    end else begin 
      {mem_data_in1,mem_data_in0} <= {in_sr[31:0]};
    end
  end else begin
      {mem_data_in1,mem_data_in0} <= {data_in,data_in};
  end
end

always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    out_count <= 2'd0;
  end else begin
    if `MV_RAM_TO_OUTPUT begin
      out_count <= out_count + 2'd2 - 2'd1;
    end else if `MV_INPUT_TO_OUTPUT begin
      out_count <= input_count - 2'd1;
    end else if (int_ren_sync_to_read_phase==1'b1 || (~int_ren_sync_to_read_phase && int_ren==1'b1 && phase==1'b0 && (out_count >0))) begin
      if (out_count>0) out_count <= out_count - 2'd1;
    end    
  end
end

//NB: Data is available for registering during the WRITE phase
always @(posedge clk) begin
  if `MV_RAM_TO_OUTPUT begin
    out_sr <= {mem_data_out1,mem_data_out0};
  end else if `MV_INPUT_TO_OUTPUT begin
    if (input_count==2'd1) begin
      out_sr[31:16] <= {in_sr[15:0]};
    end else if (input_count==2'd2) begin
      out_sr <= {in_sr[31:0]};
    end else begin
      out_sr <= {in_sr[47:16]};      
    end
  end else if (int_valid) begin
      out_sr <= (out_sr << 16);
  end
end

always @(posedge clk) begin
  data_out_d1 <= out_sr[31:16];
end

always @(posedge clk) begin
  addr_d1 <= addr; 
end


always @(*) begin
  if (config_mem[1:0]==2'd1 || config_mem[1:0]==2'd0) begin
    data_out = (out_delay==1'b1)?data_out_d1:out_sr[31:16];
  end else begin
    data_out = (addr_d1[9]==1'b1)?mem_data_out1:mem_data_out0;
  end
end



mem_unq1  mem_inst0
(
.data_out(mem_data_out0),
.data_in(mem_data_in0),
.clk(gclk),
.cen(int_cen),
.wen(int_wen),
.addr(mem_addr[8:0])
);

mem_unq1  mem_inst1
(
.data_out(mem_data_out1),
.data_in(mem_data_in1),
.clk(gclk),
.cen(int_cen),
.wen(int_wen),
.addr(mem_addr[8:0])
);
endmodule


